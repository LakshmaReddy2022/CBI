import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _asyncIterator from "@babel/runtime/helpers/asyncIterator";
import updateEach from './updateEach.js';
export default function callAsyncIterator(asyncIterator, memoized) {
  return new Promise( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {
      var isPending, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              memoized.cancel = function () {
                return asyncIterator.return();
              };

              isPending = true;
              _context.prev = 2;
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context.prev = 5;
              _iterator = _asyncIterator(asyncIterator);

            case 7:
              _context.next = 9;
              return _iterator.next();

            case 9:
              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                _context.next = 15;
                break;
              }

              value = _step.value;

              if (isPending) {
                isPending = false;
                resolve(value);
              } else {
                memoized.value = [null, value];
                updateEach(memoized);
              }

            case 12:
              _iteratorAbruptCompletion = false;
              _context.next = 7;
              break;

            case 15:
              _context.next = 21;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](5);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 21:
              _context.prev = 21;
              _context.prev = 22;

              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                _context.next = 26;
                break;
              }

              _context.next = 26;
              return _iterator.return();

            case 26:
              _context.prev = 26;

              if (!_didIteratorError) {
                _context.next = 29;
                break;
              }

              throw _iteratorError;

            case 29:
              return _context.finish(26);

            case 30:
              return _context.finish(21);

            case 31:
              _context.next = 36;
              break;

            case 33:
              _context.prev = 33;
              _context.t1 = _context["catch"](2);

              if (isPending) {
                isPending = false;
                reject(_context.t1);
              } else {
                memoized.value = [_context.t1];
                updateEach(memoized);
              }

            case 36:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 33], [5, 17, 21, 31], [22,, 26, 30]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
}
//# sourceMappingURL=callAsyncIterator.js.map